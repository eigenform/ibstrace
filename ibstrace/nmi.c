// SPDX-License-Identifier: GPL-2.0

#include <linux/nmi.h>

#include <ibstrace.h>
#include "state.h"
#include "msr.h"

extern struct ibstrace_state state;

//static u64 lsfr4(void)
//{
//	static u64 tmp = 0xdead;
//	u64 bit;
//	bit = ((tmp >> 0) ^ (tmp >> 2) ^ (tmp >> 3) ^ (tmp >> 5)) & 1;
//	tmp = (tmp >> 1) | (bit << 15);
//	return tmp & 0xf;
//}

// Read the IBS data registers, then clear them.
static void read_sample_data(struct sample *sample, struct pt_regs *regs)
{
	rdmsrl(IBS_OP_CTL, sample->op_ctl);
	rdmsrl(IBS_OP_DATA, sample->op_data);
	rdmsrl(IBS_OP_DATA2, sample->op_data2);
	rdmsrl(IBS_OP_DATA3, sample->op_data3);
	rdmsrl(IBS_DC_LIN_AD, sample->dc_lin_addr);
	rdmsrl(IBS_DC_PHYS_AD, sample->dc_phys_addr);
	rdmsrl(IBS_OP_RIP, sample->op_rip);
	rdmsrl(BP_IBSTGT_RIP, sample->tgt_rip);

	wrmsrl(IBS_OP_DATA, 0);
	wrmsrl(IBS_OP_DATA2, 0);
	wrmsrl(IBS_OP_DATA3, 0);
	wrmsrl(IBS_DC_LIN_AD, 0);
	wrmsrl(IBS_DC_PHYS_AD, 0);
	wrmsrl(IBS_OP_RIP, 0);
	wrmsrl(BP_IBSTGT_RIP, 0);
}

// The handler for IBS non-maskable interrupts. 
int ibs_nmi_handler(unsigned int cmd, struct pt_regs *regs)
{
	u64 ibs_op_ctl;
	u64 ibs_op_rip;
	long sample_idx;
	struct sample *this_sample;
	rdmsrl(IBS_OP_CTL, ibs_op_ctl);

	rdmsrl(IBS_OP_RIP, ibs_op_rip);

	// If the sample valid bit is set, this is an IBS NMI
	if (ibs_op_ctl & IBS_OP_VAL) {

		// If we don't have any more space to store samples, just return
		sample_idx = atomic_long_read(&state.samples_collected);
		if (sample_idx >= state.sample_buf_capacity) {
			return NMI_HANDLED;
		}

		//// Hanging NMI, I guess
		//if (ibs_op_ctl == 0) { 
		//	return NMI_HANDLED; 
		//}

		// If IBS_OP_MAX_CNT is zeroed out, this is a hanging NMI 
		// that occured after clearing the IBS_OP_EN bit
		//if (!(ibs_op_ctl & IBS_OP_MAX_CNT)) {
		//	return NMI_HANDLED; 
		//}

		//if (ibs_op_rip == 0) {
		//	return NMI_HANDLED;
		//}

		// Collect the sample
		this_sample = &state.sample_buf[sample_idx];
		read_sample_data(this_sample, regs);
		atomic_long_inc(&state.samples_collected);

		// Reconfigure IBS_OP_CTL so we can handle another sample.
		// NOTE: I think we only need to clear the sample-valid bit here.
		// Reconfiguring the current counter shouldn't be necessary?
	
		ibs_op_ctl &= ~IBS_OP_VAL;
		ibs_op_ctl = 0;
		wrmsrl(IBS_OP_CTL, ibs_op_ctl);

		return NMI_HANDLED;
	}

	// If we reach this point, we've probably caught an NMI that we aren't 
	// responsible for (not generated by IBS), so we should avoid marking it 
	// as handled.

	return NMI_DONE;
}


