// SPDX-License-Identifier: GPL-2.0

#include <linux/nmi.h>

#include <ibstrace.h>
#include "state.h"
#include "msr.h"

extern struct ibstrace_state state;

// Read the IBS data registers, then clear them.
static void read_sample_data(struct sample *sample, struct pt_regs *regs)
{
	rdmsrl(IBS_OP_CTL, sample->op_ctl);
	rdmsrl(IBS_OP_DATA, sample->op_data);
	rdmsrl(IBS_OP_DATA2, sample->op_data2);
	rdmsrl(IBS_OP_DATA3, sample->op_data3);
	rdmsrl(IBS_DC_LIN_AD, sample->dc_lin_addr);
	rdmsrl(IBS_DC_PHYS_AD, sample->dc_phys_addr);
	rdmsrl(IBS_OP_RIP, sample->op_rip);
	rdmsrl(BP_IBSTGT_RIP, sample->tgt_rip);

	wrmsrl(IBS_OP_DATA, 0);
	wrmsrl(IBS_OP_DATA2, 0);
	wrmsrl(IBS_OP_DATA3, 0);
	wrmsrl(IBS_DC_LIN_AD, 0);
	wrmsrl(IBS_DC_PHYS_AD, 0);
	wrmsrl(IBS_OP_RIP, 0);
	wrmsrl(BP_IBSTGT_RIP, 0);
}

// The handler for IBS non-maskable interrupts. 
int ibs_nmi_handler(unsigned int cmd, struct pt_regs *regs)
{
	u64 ibs_op_ctl;
	u64 ibs_op_rip;
	long sample_idx;
	long precise_mode;
	struct sample *this_sample;
	rdmsrl(IBS_OP_CTL, ibs_op_ctl);

	rdmsrl(IBS_OP_RIP, ibs_op_rip);

	// If the valid bit is set, this is [probably] an IBS NMI
	if (ibs_op_ctl & IBS_OP_VAL) {

		// If we don't have any more space to store samples, just return
		sample_idx = atomic_long_read(&state.samples_collected);
		if (sample_idx >= state.sample_buf_capacity) {
			return NMI_HANDLED;
		}

		// Are we handling "normal" or "precise" sampling?
		precise_mode = atomic_long_read(&state.precise_mode);

		//// Hanging NMI, I guess
		//if (ibs_op_ctl == 0) { 
		//	return NMI_HANDLED; 
		//}

		// If IBS_OP_MAX_CNT is zeroed out, this is a hanging NMI 
		// that occured after clearing the IBS_OP_EN bit
		//if (!(ibs_op_ctl & IBS_OP_MAX_CNT)) {
		//	return NMI_HANDLED; 
		//}

		//if (ibs_op_rip == 0) {
		//	return NMI_HANDLED;
		//}

		// Collect the sample
		this_sample = &state.sample_buf[sample_idx];
		read_sample_data(this_sample, regs);
		atomic_long_inc(&state.samples_collected);

		// For "normal" sampling, reconfigure IBS_OP_CTL so we can handle 
		// another sample (presumably we just clear the valid bit). 
		// Otherwise, for "precise sampling" (yielding a single sample), 
		// simply clear IBS_OP_CTL. 
		if (precise_mode == 0) {
			ibs_op_ctl &= ~IBS_OP_VAL;
		} else {
			ibs_op_ctl = 0;
		}

		wrmsrl(IBS_OP_CTL, ibs_op_ctl);

		return NMI_HANDLED;
	}

	// If we reach this point, we've probably caught an NMI that we aren't 
	// responsible for (not generated by IBS), so we should avoid marking it 
	// as handled.

	return NMI_DONE;
}


